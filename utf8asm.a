;ACME 0.97

; welche Fehler sind denkbar?
;	-unerwartete Fortsetzungsbytes (zuviele bzw. ganz ohne Startbyte)
;	-fehlende Fortsetzungsbytes
;	-verbotene Bytes (0xc0, 0xc1, 0xf8+)

	!to "utf8asm.boot", cbm
	!ct pet
	* = $1300

	CHAR_CODING_ERROR	= '!'	; char to output in case of encoding error
	CHAR_UNSUPPORTED	= 'X'	; char to output for unsupported code points

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; UTF-8 decoder

; first entry point: init / reset / clear error flag
		jmp .init
; second entry point: feed a byte to decoder
		;jmp decode_byte_A
;decode_byte_A
		tax	; check msb and buffer original value so we can shift A around
		bpl .ascii_AX	; handle ascii value (0x00..0x7f)
		asl
		bpl .sixbits_X	; handle continuation byte (0x80..0xbf)
		ldy #1	; minimal number of expected continuation bytes: 1
		asl
		bpl .start_sequence_X_Y_check	; handle 0xc0..0xdf (start of two-byte sequence)
		iny;ldy#2	minimal number of expected continuation bytes: 2
		asl
		bpl .start_sequence_X_Y	; handle 0xe0..0xef (start of three-byte sequence)
		iny;ldy#3	minimal number of expected continuation bytes: 3
		asl
		bpl .start_sequence_X_Y	; handle 0xf0..0xf7 (start of four-byte sequence)
		; definitions for five-byte and six-byte sequences have been
		; withdrawn, and $fe and $ff are forbidden as well, therefore:
		;FALLTHROUGH
.coding_error	lda .expected_bytes
		bmi .rts	; already ignoring? then keep ignoring
		jsr .error_out
		lda #$ff
		!by $2c
.init		lda #0
		sta .expected_bytes
.rts		rts

; number of continuation bytes to expect (ff/0/1/2/3, where $ff means infinity, i.e. error state)
.expected_bytes	!by 0
; byte sequence
.seq_length	!by 0	; will be 2/3/4 when calling out_sequence
.byte_sequence	!by 0, 0, 0, 0	; example: Euro sign would be $e2, $82, $ac, dontcare

.sixbits_X ; it's a continuation byte (passed in X)
		ldy .expected_bytes
		bmi .rts	; ignore -> keep ignoring
		beq .coding_error	; ok -> complain and start ignoring
		txa	; store byte in memory
		ldx .seq_length
		sta .byte_sequence, x
		inx
		stx .seq_length
		dec .expected_bytes
		bne .rts	; more to follow
		jmp out_sequence_X	; convert and output

.start_sequence_X_Y_check ; X is byte, Y is number of continuation bytes expected to follow
		cpx #$c2	; 0xc0 and 0xc1 are illegal, because they can only
		bcc .coding_error	; start code points that already fit in ascii!
.start_sequence_X_Y ; X is byte, Y is number of continuation bytes expected to follow
		stx .byte_sequence
		lda #1
		sta .seq_length
.new_state_Y ; Y is number of continuation bytes expected to follow
		lda .expected_bytes	; check old status
		sty .expected_bytes	; and set new one
		beq .rts	; ok -> ok
		bmi .rts	; ignore -> ok, we start a fresh sequence anyway
		; expecting -> show error because previous code point has not been finished
		; we expected continuation bytes, so we output the error char,
		; but we do not enter the "ignore" state because we already have
		; new valid data:
.error_out	lda #CHAR_CODING_ERROR
		jmp $ffd2

; handler for ASCII values (0x00..0x7f):
.ascii_AX ; value is passed in both A and X
		pha
		ldy #0	; new state (no continuation bytes)
		jsr .new_state_Y
		pla
		;jmp out_ascii_A
		;FALLTHROUGH
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; converter
out_ascii_A ; output code points in 0x00..0x7f range
		; 00..1f -> convert LF and CR
		; 41..5a -> add 0x80
		; 61..7a -> subtract 0x20
		cmp #$41
		bcc ._00_40
		cmp #$5b
		bcc ._41_5a
		cmp #$61
		bcc .keep
		cmp #$7b
		bcc ._61_7a
.keep		jmp $ffd2

._00_40		cmp #13	; CR -> ignore
		bne ++
			rts
++		cmp #10	; LF -> CR
		bne ++
			lda #13
++		ldx #0
		stx $f4	; make sure TABs are not quoted
		jmp $ffd2

._41_5a		ora #$80
		jmp $ffd2

._61_7a		and #$df
		jmp $ffd2

out_sequence_X ; output code points in 0x80..0x1fffff range, X is length of byte sequence (2/3/4)
		;lda #CHAR_UNSUPPORTED
		txa
		ora #$30	; now we output '2', '3' or '4'
		jmp $ffd2
